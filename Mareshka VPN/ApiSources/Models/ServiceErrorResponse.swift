//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class ServiceErrorResponse: APIModel {

    public var advices: [String]?

    public var code: String?

    public var error: String?

    public var status: Int?

    public var trace: [Trace]?

    public class Trace: APIModel {

        public var classLoaderName: String?

        public var className: String?

        public var fileName: String?

        public var lineNumber: Int?

        public var methodName: String?

        public var moduleName: String?

        public var moduleVersion: String?

        public var nativeMethod: Bool?

        public init(classLoaderName: String? = nil, className: String? = nil, fileName: String? = nil, lineNumber: Int? = nil, methodName: String? = nil, moduleName: String? = nil, moduleVersion: String? = nil, nativeMethod: Bool? = nil) {
            self.classLoaderName = classLoaderName
            self.className = className
            self.fileName = fileName
            self.lineNumber = lineNumber
            self.methodName = methodName
            self.moduleName = moduleName
            self.moduleVersion = moduleVersion
            self.nativeMethod = nativeMethod
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            classLoaderName = try container.decodeIfPresent("classLoaderName")
            className = try container.decodeIfPresent("className")
            fileName = try container.decodeIfPresent("fileName")
            lineNumber = try container.decodeIfPresent("lineNumber")
            methodName = try container.decodeIfPresent("methodName")
            moduleName = try container.decodeIfPresent("moduleName")
            moduleVersion = try container.decodeIfPresent("moduleVersion")
            nativeMethod = try container.decodeIfPresent("nativeMethod")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(classLoaderName, forKey: "classLoaderName")
            try container.encodeIfPresent(className, forKey: "className")
            try container.encodeIfPresent(fileName, forKey: "fileName")
            try container.encodeIfPresent(lineNumber, forKey: "lineNumber")
            try container.encodeIfPresent(methodName, forKey: "methodName")
            try container.encodeIfPresent(moduleName, forKey: "moduleName")
            try container.encodeIfPresent(moduleVersion, forKey: "moduleVersion")
            try container.encodeIfPresent(nativeMethod, forKey: "nativeMethod")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Trace else { return false }
          guard self.classLoaderName == object.classLoaderName else { return false }
          guard self.className == object.className else { return false }
          guard self.fileName == object.fileName else { return false }
          guard self.lineNumber == object.lineNumber else { return false }
          guard self.methodName == object.methodName else { return false }
          guard self.moduleName == object.moduleName else { return false }
          guard self.moduleVersion == object.moduleVersion else { return false }
          guard self.nativeMethod == object.nativeMethod else { return false }
          return true
        }

        public static func == (lhs: Trace, rhs: Trace) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(advices: [String]? = nil, code: String? = nil, error: String? = nil, status: Int? = nil, trace: [Trace]? = nil) {
        self.advices = advices
        self.code = code
        self.error = error
        self.status = status
        self.trace = trace
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        advices = try container.decodeArrayIfPresent("advices")
        code = try container.decodeIfPresent("code")
        error = try container.decodeIfPresent("error")
        status = try container.decodeIfPresent("status")
        trace = try container.decodeArrayIfPresent("trace")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(advices, forKey: "advices")
        try container.encodeIfPresent(code, forKey: "code")
        try container.encodeIfPresent(error, forKey: "error")
        try container.encodeIfPresent(status, forKey: "status")
        try container.encodeIfPresent(trace, forKey: "trace")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ServiceErrorResponse else { return false }
      guard self.advices == object.advices else { return false }
      guard self.code == object.code else { return false }
      guard self.error == object.error else { return false }
      guard self.status == object.status else { return false }
      guard self.trace == object.trace else { return false }
      return true
    }

    public static func == (lhs: ServiceErrorResponse, rhs: ServiceErrorResponse) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
