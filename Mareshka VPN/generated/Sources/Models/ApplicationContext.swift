//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class ApplicationContext: APIModel {

    public var applicationName: String?

    public var autowireCapableBeanFactory: AutowireCapableBeanFactory?

    public var beanDefinitionCount: Int?

    public var beanDefinitionNames: [String]?

    public var classLoader: ClassLoader?

    public var displayName: String?

    public var environment: Environment?

    public var id: String?

    public var parent: ApplicationContext?

    public var parentBeanFactory: BeanFactory?

    public var startupDate: Int?

    public class ClassLoader: APIModel {

        public var defaultAssertionStatus: Bool?

        public var definedPackages: [DefinedPackages]?

        public var name: String?

        public var parent: Parent?

        public var registeredAsParallelCapable: Bool?

        public var unnamedModule: UnnamedModule?

        public class DefinedPackages: APIModel {

            public var annotations: [[String: Any]]?

            public var declaredAnnotations: [[String: Any]]?

            public var implementationTitle: String?

            public var implementationVendor: String?

            public var implementationVersion: String?

            public var name: String?

            public var sealed: Bool?

            public var specificationTitle: String?

            public var specificationVendor: String?

            public var specificationVersion: String?

            public init(annotations: [[String: Any]]? = nil, declaredAnnotations: [[String: Any]]? = nil, implementationTitle: String? = nil, implementationVendor: String? = nil, implementationVersion: String? = nil, name: String? = nil, sealed: Bool? = nil, specificationTitle: String? = nil, specificationVendor: String? = nil, specificationVersion: String? = nil) {
                self.annotations = annotations
                self.declaredAnnotations = declaredAnnotations
                self.implementationTitle = implementationTitle
                self.implementationVendor = implementationVendor
                self.implementationVersion = implementationVersion
                self.name = name
                self.sealed = sealed
                self.specificationTitle = specificationTitle
                self.specificationVendor = specificationVendor
                self.specificationVersion = specificationVersion
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                annotations = try container.decodeAnyIfPresent("annotations")
                declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                implementationTitle = try container.decodeIfPresent("implementationTitle")
                implementationVendor = try container.decodeIfPresent("implementationVendor")
                implementationVersion = try container.decodeIfPresent("implementationVersion")
                name = try container.decodeIfPresent("name")
                sealed = try container.decodeIfPresent("sealed")
                specificationTitle = try container.decodeIfPresent("specificationTitle")
                specificationVendor = try container.decodeIfPresent("specificationVendor")
                specificationVersion = try container.decodeIfPresent("specificationVersion")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                try container.encodeIfPresent(implementationTitle, forKey: "implementationTitle")
                try container.encodeIfPresent(implementationVendor, forKey: "implementationVendor")
                try container.encodeIfPresent(implementationVersion, forKey: "implementationVersion")
                try container.encodeIfPresent(name, forKey: "name")
                try container.encodeIfPresent(sealed, forKey: "sealed")
                try container.encodeIfPresent(specificationTitle, forKey: "specificationTitle")
                try container.encodeIfPresent(specificationVendor, forKey: "specificationVendor")
                try container.encodeIfPresent(specificationVersion, forKey: "specificationVersion")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? DefinedPackages else { return false }
              guard self.annotations == object.annotations else { return false }
              guard self.declaredAnnotations == object.declaredAnnotations else { return false }
              guard self.implementationTitle == object.implementationTitle else { return false }
              guard self.implementationVendor == object.implementationVendor else { return false }
              guard self.implementationVersion == object.implementationVersion else { return false }
              guard self.name == object.name else { return false }
              guard self.sealed == object.sealed else { return false }
              guard self.specificationTitle == object.specificationTitle else { return false }
              guard self.specificationVendor == object.specificationVendor else { return false }
              guard self.specificationVersion == object.specificationVersion else { return false }
              return true
            }

            public static func == (lhs: DefinedPackages, rhs: DefinedPackages) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class Parent: APIModel {

            public var defaultAssertionStatus: Bool?

            public var definedPackages: [DefinedPackages]?

            public var name: String?

            public var registeredAsParallelCapable: Bool?

            public var unnamedModule: UnnamedModule?

            public class DefinedPackages: APIModel {

                public var annotations: [[String: Any]]?

                public var declaredAnnotations: [[String: Any]]?

                public var implementationTitle: String?

                public var implementationVendor: String?

                public var implementationVersion: String?

                public var name: String?

                public var sealed: Bool?

                public var specificationTitle: String?

                public var specificationVendor: String?

                public var specificationVersion: String?

                public init(annotations: [[String: Any]]? = nil, declaredAnnotations: [[String: Any]]? = nil, implementationTitle: String? = nil, implementationVendor: String? = nil, implementationVersion: String? = nil, name: String? = nil, sealed: Bool? = nil, specificationTitle: String? = nil, specificationVendor: String? = nil, specificationVersion: String? = nil) {
                    self.annotations = annotations
                    self.declaredAnnotations = declaredAnnotations
                    self.implementationTitle = implementationTitle
                    self.implementationVendor = implementationVendor
                    self.implementationVersion = implementationVersion
                    self.name = name
                    self.sealed = sealed
                    self.specificationTitle = specificationTitle
                    self.specificationVendor = specificationVendor
                    self.specificationVersion = specificationVersion
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    annotations = try container.decodeAnyIfPresent("annotations")
                    declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                    implementationTitle = try container.decodeIfPresent("implementationTitle")
                    implementationVendor = try container.decodeIfPresent("implementationVendor")
                    implementationVersion = try container.decodeIfPresent("implementationVersion")
                    name = try container.decodeIfPresent("name")
                    sealed = try container.decodeIfPresent("sealed")
                    specificationTitle = try container.decodeIfPresent("specificationTitle")
                    specificationVendor = try container.decodeIfPresent("specificationVendor")
                    specificationVersion = try container.decodeIfPresent("specificationVersion")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                    try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                    try container.encodeIfPresent(implementationTitle, forKey: "implementationTitle")
                    try container.encodeIfPresent(implementationVendor, forKey: "implementationVendor")
                    try container.encodeIfPresent(implementationVersion, forKey: "implementationVersion")
                    try container.encodeIfPresent(name, forKey: "name")
                    try container.encodeIfPresent(sealed, forKey: "sealed")
                    try container.encodeIfPresent(specificationTitle, forKey: "specificationTitle")
                    try container.encodeIfPresent(specificationVendor, forKey: "specificationVendor")
                    try container.encodeIfPresent(specificationVersion, forKey: "specificationVersion")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefinedPackages else { return false }
                  guard self.annotations == object.annotations else { return false }
                  guard self.declaredAnnotations == object.declaredAnnotations else { return false }
                  guard self.implementationTitle == object.implementationTitle else { return false }
                  guard self.implementationVendor == object.implementationVendor else { return false }
                  guard self.implementationVersion == object.implementationVersion else { return false }
                  guard self.name == object.name else { return false }
                  guard self.sealed == object.sealed else { return false }
                  guard self.specificationTitle == object.specificationTitle else { return false }
                  guard self.specificationVendor == object.specificationVendor else { return false }
                  guard self.specificationVersion == object.specificationVersion else { return false }
                  return true
                }

                public static func == (lhs: DefinedPackages, rhs: DefinedPackages) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class UnnamedModule: APIModel {

                public var annotations: [[String: Any]]?

                public var classLoader: ClassLoader?

                public var declaredAnnotations: [[String: Any]]?

                public var descriptor: Descriptor?

                public var layer: [String: Any]?

                public var name: String?

                public var named: Bool?

                public var packages: [String]?

                public class ClassLoader: APIModel {

                    public var defaultAssertionStatus: Bool?

                    public var definedPackages: [DefinedPackages]?

                    public var name: String?

                    public var registeredAsParallelCapable: Bool?

                    public class DefinedPackages: APIModel {

                        public var annotations: [[String: Any]]?

                        public var declaredAnnotations: [[String: Any]]?

                        public var implementationTitle: String?

                        public var implementationVendor: String?

                        public var implementationVersion: String?

                        public var name: String?

                        public var sealed: Bool?

                        public var specificationTitle: String?

                        public var specificationVendor: String?

                        public var specificationVersion: String?

                        public init(annotations: [[String: Any]]? = nil, declaredAnnotations: [[String: Any]]? = nil, implementationTitle: String? = nil, implementationVendor: String? = nil, implementationVersion: String? = nil, name: String? = nil, sealed: Bool? = nil, specificationTitle: String? = nil, specificationVendor: String? = nil, specificationVersion: String? = nil) {
                            self.annotations = annotations
                            self.declaredAnnotations = declaredAnnotations
                            self.implementationTitle = implementationTitle
                            self.implementationVendor = implementationVendor
                            self.implementationVersion = implementationVersion
                            self.name = name
                            self.sealed = sealed
                            self.specificationTitle = specificationTitle
                            self.specificationVendor = specificationVendor
                            self.specificationVersion = specificationVersion
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            annotations = try container.decodeAnyIfPresent("annotations")
                            declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                            implementationTitle = try container.decodeIfPresent("implementationTitle")
                            implementationVendor = try container.decodeIfPresent("implementationVendor")
                            implementationVersion = try container.decodeIfPresent("implementationVersion")
                            name = try container.decodeIfPresent("name")
                            sealed = try container.decodeIfPresent("sealed")
                            specificationTitle = try container.decodeIfPresent("specificationTitle")
                            specificationVendor = try container.decodeIfPresent("specificationVendor")
                            specificationVersion = try container.decodeIfPresent("specificationVersion")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                            try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                            try container.encodeIfPresent(implementationTitle, forKey: "implementationTitle")
                            try container.encodeIfPresent(implementationVendor, forKey: "implementationVendor")
                            try container.encodeIfPresent(implementationVersion, forKey: "implementationVersion")
                            try container.encodeIfPresent(name, forKey: "name")
                            try container.encodeIfPresent(sealed, forKey: "sealed")
                            try container.encodeIfPresent(specificationTitle, forKey: "specificationTitle")
                            try container.encodeIfPresent(specificationVendor, forKey: "specificationVendor")
                            try container.encodeIfPresent(specificationVersion, forKey: "specificationVersion")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? DefinedPackages else { return false }
                          guard self.annotations == object.annotations else { return false }
                          guard self.declaredAnnotations == object.declaredAnnotations else { return false }
                          guard self.implementationTitle == object.implementationTitle else { return false }
                          guard self.implementationVendor == object.implementationVendor else { return false }
                          guard self.implementationVersion == object.implementationVersion else { return false }
                          guard self.name == object.name else { return false }
                          guard self.sealed == object.sealed else { return false }
                          guard self.specificationTitle == object.specificationTitle else { return false }
                          guard self.specificationVendor == object.specificationVendor else { return false }
                          guard self.specificationVersion == object.specificationVersion else { return false }
                          return true
                        }

                        public static func == (lhs: DefinedPackages, rhs: DefinedPackages) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(defaultAssertionStatus: Bool? = nil, definedPackages: [DefinedPackages]? = nil, name: String? = nil, registeredAsParallelCapable: Bool? = nil) {
                        self.defaultAssertionStatus = defaultAssertionStatus
                        self.definedPackages = definedPackages
                        self.name = name
                        self.registeredAsParallelCapable = registeredAsParallelCapable
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        defaultAssertionStatus = try container.decodeIfPresent("defaultAssertionStatus")
                        definedPackages = try container.decodeArrayIfPresent("definedPackages")
                        name = try container.decodeIfPresent("name")
                        registeredAsParallelCapable = try container.decodeIfPresent("registeredAsParallelCapable")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(defaultAssertionStatus, forKey: "defaultAssertionStatus")
                        try container.encodeIfPresent(definedPackages, forKey: "definedPackages")
                        try container.encodeIfPresent(name, forKey: "name")
                        try container.encodeIfPresent(registeredAsParallelCapable, forKey: "registeredAsParallelCapable")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ClassLoader else { return false }
                      guard self.defaultAssertionStatus == object.defaultAssertionStatus else { return false }
                      guard self.definedPackages == object.definedPackages else { return false }
                      guard self.name == object.name else { return false }
                      guard self.registeredAsParallelCapable == object.registeredAsParallelCapable else { return false }
                      return true
                    }

                    public static func == (lhs: ClassLoader, rhs: ClassLoader) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public class Descriptor: APIModel {

                    public var automatic: Bool?

                    public var `open`: Bool?

                    public init(automatic: Bool? = nil, `open`: Bool? = nil) {
                        self.automatic = automatic
                        self.`open` = `open`
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        automatic = try container.decodeIfPresent("automatic")
                        `open` = try container.decodeIfPresent("open")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(automatic, forKey: "automatic")
                        try container.encodeIfPresent(`open`, forKey: "open")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Descriptor else { return false }
                      guard self.automatic == object.automatic else { return false }
                      guard self.`open` == object.`open` else { return false }
                      return true
                    }

                    public static func == (lhs: Descriptor, rhs: Descriptor) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(annotations: [[String: Any]]? = nil, classLoader: ClassLoader? = nil, declaredAnnotations: [[String: Any]]? = nil, descriptor: Descriptor? = nil, layer: [String: Any]? = nil, name: String? = nil, named: Bool? = nil, packages: [String]? = nil) {
                    self.annotations = annotations
                    self.classLoader = classLoader
                    self.declaredAnnotations = declaredAnnotations
                    self.descriptor = descriptor
                    self.layer = layer
                    self.name = name
                    self.named = named
                    self.packages = packages
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    annotations = try container.decodeAnyIfPresent("annotations")
                    classLoader = try container.decodeIfPresent("classLoader")
                    declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                    descriptor = try container.decodeIfPresent("descriptor")
                    layer = try container.decodeAnyIfPresent("layer")
                    name = try container.decodeIfPresent("name")
                    named = try container.decodeIfPresent("named")
                    packages = try container.decodeArrayIfPresent("packages")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                    try container.encodeIfPresent(classLoader, forKey: "classLoader")
                    try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                    try container.encodeIfPresent(descriptor, forKey: "descriptor")
                    try container.encodeAnyIfPresent(layer, forKey: "layer")
                    try container.encodeIfPresent(name, forKey: "name")
                    try container.encodeIfPresent(named, forKey: "named")
                    try container.encodeIfPresent(packages, forKey: "packages")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? UnnamedModule else { return false }
                  guard self.annotations == object.annotations else { return false }
                  guard self.classLoader == object.classLoader else { return false }
                  guard self.declaredAnnotations == object.declaredAnnotations else { return false }
                  guard self.descriptor == object.descriptor else { return false }
                  guard NSDictionary(dictionary: self.layer ?? [:]).isEqual(to: object.layer ?? [:]) else { return false }
                  guard self.name == object.name else { return false }
                  guard self.named == object.named else { return false }
                  guard self.packages == object.packages else { return false }
                  return true
                }

                public static func == (lhs: UnnamedModule, rhs: UnnamedModule) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(defaultAssertionStatus: Bool? = nil, definedPackages: [DefinedPackages]? = nil, name: String? = nil, registeredAsParallelCapable: Bool? = nil, unnamedModule: UnnamedModule? = nil) {
                self.defaultAssertionStatus = defaultAssertionStatus
                self.definedPackages = definedPackages
                self.name = name
                self.registeredAsParallelCapable = registeredAsParallelCapable
                self.unnamedModule = unnamedModule
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                defaultAssertionStatus = try container.decodeIfPresent("defaultAssertionStatus")
                definedPackages = try container.decodeArrayIfPresent("definedPackages")
                name = try container.decodeIfPresent("name")
                registeredAsParallelCapable = try container.decodeIfPresent("registeredAsParallelCapable")
                unnamedModule = try container.decodeIfPresent("unnamedModule")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(defaultAssertionStatus, forKey: "defaultAssertionStatus")
                try container.encodeIfPresent(definedPackages, forKey: "definedPackages")
                try container.encodeIfPresent(name, forKey: "name")
                try container.encodeIfPresent(registeredAsParallelCapable, forKey: "registeredAsParallelCapable")
                try container.encodeIfPresent(unnamedModule, forKey: "unnamedModule")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Parent else { return false }
              guard self.defaultAssertionStatus == object.defaultAssertionStatus else { return false }
              guard self.definedPackages == object.definedPackages else { return false }
              guard self.name == object.name else { return false }
              guard self.registeredAsParallelCapable == object.registeredAsParallelCapable else { return false }
              guard self.unnamedModule == object.unnamedModule else { return false }
              return true
            }

            public static func == (lhs: Parent, rhs: Parent) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class UnnamedModule: APIModel {

            public var annotations: [[String: Any]]?

            public var classLoader: ClassLoader?

            public var declaredAnnotations: [[String: Any]]?

            public var descriptor: Descriptor?

            public var layer: [String: Any]?

            public var name: String?

            public var named: Bool?

            public var packages: [String]?

            public class ClassLoader: APIModel {

                public var defaultAssertionStatus: Bool?

                public var definedPackages: [DefinedPackages]?

                public var name: String?

                public var registeredAsParallelCapable: Bool?

                public class DefinedPackages: APIModel {

                    public var annotations: [[String: Any]]?

                    public var declaredAnnotations: [[String: Any]]?

                    public var implementationTitle: String?

                    public var implementationVendor: String?

                    public var implementationVersion: String?

                    public var name: String?

                    public var sealed: Bool?

                    public var specificationTitle: String?

                    public var specificationVendor: String?

                    public var specificationVersion: String?

                    public init(annotations: [[String: Any]]? = nil, declaredAnnotations: [[String: Any]]? = nil, implementationTitle: String? = nil, implementationVendor: String? = nil, implementationVersion: String? = nil, name: String? = nil, sealed: Bool? = nil, specificationTitle: String? = nil, specificationVendor: String? = nil, specificationVersion: String? = nil) {
                        self.annotations = annotations
                        self.declaredAnnotations = declaredAnnotations
                        self.implementationTitle = implementationTitle
                        self.implementationVendor = implementationVendor
                        self.implementationVersion = implementationVersion
                        self.name = name
                        self.sealed = sealed
                        self.specificationTitle = specificationTitle
                        self.specificationVendor = specificationVendor
                        self.specificationVersion = specificationVersion
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        annotations = try container.decodeAnyIfPresent("annotations")
                        declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                        implementationTitle = try container.decodeIfPresent("implementationTitle")
                        implementationVendor = try container.decodeIfPresent("implementationVendor")
                        implementationVersion = try container.decodeIfPresent("implementationVersion")
                        name = try container.decodeIfPresent("name")
                        sealed = try container.decodeIfPresent("sealed")
                        specificationTitle = try container.decodeIfPresent("specificationTitle")
                        specificationVendor = try container.decodeIfPresent("specificationVendor")
                        specificationVersion = try container.decodeIfPresent("specificationVersion")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                        try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                        try container.encodeIfPresent(implementationTitle, forKey: "implementationTitle")
                        try container.encodeIfPresent(implementationVendor, forKey: "implementationVendor")
                        try container.encodeIfPresent(implementationVersion, forKey: "implementationVersion")
                        try container.encodeIfPresent(name, forKey: "name")
                        try container.encodeIfPresent(sealed, forKey: "sealed")
                        try container.encodeIfPresent(specificationTitle, forKey: "specificationTitle")
                        try container.encodeIfPresent(specificationVendor, forKey: "specificationVendor")
                        try container.encodeIfPresent(specificationVersion, forKey: "specificationVersion")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? DefinedPackages else { return false }
                      guard self.annotations == object.annotations else { return false }
                      guard self.declaredAnnotations == object.declaredAnnotations else { return false }
                      guard self.implementationTitle == object.implementationTitle else { return false }
                      guard self.implementationVendor == object.implementationVendor else { return false }
                      guard self.implementationVersion == object.implementationVersion else { return false }
                      guard self.name == object.name else { return false }
                      guard self.sealed == object.sealed else { return false }
                      guard self.specificationTitle == object.specificationTitle else { return false }
                      guard self.specificationVendor == object.specificationVendor else { return false }
                      guard self.specificationVersion == object.specificationVersion else { return false }
                      return true
                    }

                    public static func == (lhs: DefinedPackages, rhs: DefinedPackages) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(defaultAssertionStatus: Bool? = nil, definedPackages: [DefinedPackages]? = nil, name: String? = nil, registeredAsParallelCapable: Bool? = nil) {
                    self.defaultAssertionStatus = defaultAssertionStatus
                    self.definedPackages = definedPackages
                    self.name = name
                    self.registeredAsParallelCapable = registeredAsParallelCapable
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    defaultAssertionStatus = try container.decodeIfPresent("defaultAssertionStatus")
                    definedPackages = try container.decodeArrayIfPresent("definedPackages")
                    name = try container.decodeIfPresent("name")
                    registeredAsParallelCapable = try container.decodeIfPresent("registeredAsParallelCapable")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(defaultAssertionStatus, forKey: "defaultAssertionStatus")
                    try container.encodeIfPresent(definedPackages, forKey: "definedPackages")
                    try container.encodeIfPresent(name, forKey: "name")
                    try container.encodeIfPresent(registeredAsParallelCapable, forKey: "registeredAsParallelCapable")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? ClassLoader else { return false }
                  guard self.defaultAssertionStatus == object.defaultAssertionStatus else { return false }
                  guard self.definedPackages == object.definedPackages else { return false }
                  guard self.name == object.name else { return false }
                  guard self.registeredAsParallelCapable == object.registeredAsParallelCapable else { return false }
                  return true
                }

                public static func == (lhs: ClassLoader, rhs: ClassLoader) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class Descriptor: APIModel {

                public var automatic: Bool?

                public var `open`: Bool?

                public init(automatic: Bool? = nil, `open`: Bool? = nil) {
                    self.automatic = automatic
                    self.`open` = `open`
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    automatic = try container.decodeIfPresent("automatic")
                    `open` = try container.decodeIfPresent("open")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(automatic, forKey: "automatic")
                    try container.encodeIfPresent(`open`, forKey: "open")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Descriptor else { return false }
                  guard self.automatic == object.automatic else { return false }
                  guard self.`open` == object.`open` else { return false }
                  return true
                }

                public static func == (lhs: Descriptor, rhs: Descriptor) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(annotations: [[String: Any]]? = nil, classLoader: ClassLoader? = nil, declaredAnnotations: [[String: Any]]? = nil, descriptor: Descriptor? = nil, layer: [String: Any]? = nil, name: String? = nil, named: Bool? = nil, packages: [String]? = nil) {
                self.annotations = annotations
                self.classLoader = classLoader
                self.declaredAnnotations = declaredAnnotations
                self.descriptor = descriptor
                self.layer = layer
                self.name = name
                self.named = named
                self.packages = packages
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                annotations = try container.decodeAnyIfPresent("annotations")
                classLoader = try container.decodeIfPresent("classLoader")
                declaredAnnotations = try container.decodeAnyIfPresent("declaredAnnotations")
                descriptor = try container.decodeIfPresent("descriptor")
                layer = try container.decodeAnyIfPresent("layer")
                name = try container.decodeIfPresent("name")
                named = try container.decodeIfPresent("named")
                packages = try container.decodeArrayIfPresent("packages")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeAnyIfPresent(annotations, forKey: "annotations")
                try container.encodeIfPresent(classLoader, forKey: "classLoader")
                try container.encodeAnyIfPresent(declaredAnnotations, forKey: "declaredAnnotations")
                try container.encodeIfPresent(descriptor, forKey: "descriptor")
                try container.encodeAnyIfPresent(layer, forKey: "layer")
                try container.encodeIfPresent(name, forKey: "name")
                try container.encodeIfPresent(named, forKey: "named")
                try container.encodeIfPresent(packages, forKey: "packages")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? UnnamedModule else { return false }
              guard self.annotations == object.annotations else { return false }
              guard self.classLoader == object.classLoader else { return false }
              guard self.declaredAnnotations == object.declaredAnnotations else { return false }
              guard self.descriptor == object.descriptor else { return false }
              guard NSDictionary(dictionary: self.layer ?? [:]).isEqual(to: object.layer ?? [:]) else { return false }
              guard self.name == object.name else { return false }
              guard self.named == object.named else { return false }
              guard self.packages == object.packages else { return false }
              return true
            }

            public static func == (lhs: UnnamedModule, rhs: UnnamedModule) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(defaultAssertionStatus: Bool? = nil, definedPackages: [DefinedPackages]? = nil, name: String? = nil, parent: Parent? = nil, registeredAsParallelCapable: Bool? = nil, unnamedModule: UnnamedModule? = nil) {
            self.defaultAssertionStatus = defaultAssertionStatus
            self.definedPackages = definedPackages
            self.name = name
            self.parent = parent
            self.registeredAsParallelCapable = registeredAsParallelCapable
            self.unnamedModule = unnamedModule
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            defaultAssertionStatus = try container.decodeIfPresent("defaultAssertionStatus")
            definedPackages = try container.decodeArrayIfPresent("definedPackages")
            name = try container.decodeIfPresent("name")
            parent = try container.decodeIfPresent("parent")
            registeredAsParallelCapable = try container.decodeIfPresent("registeredAsParallelCapable")
            unnamedModule = try container.decodeIfPresent("unnamedModule")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(defaultAssertionStatus, forKey: "defaultAssertionStatus")
            try container.encodeIfPresent(definedPackages, forKey: "definedPackages")
            try container.encodeIfPresent(name, forKey: "name")
            try container.encodeIfPresent(parent, forKey: "parent")
            try container.encodeIfPresent(registeredAsParallelCapable, forKey: "registeredAsParallelCapable")
            try container.encodeIfPresent(unnamedModule, forKey: "unnamedModule")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? ClassLoader else { return false }
          guard self.defaultAssertionStatus == object.defaultAssertionStatus else { return false }
          guard self.definedPackages == object.definedPackages else { return false }
          guard self.name == object.name else { return false }
          guard self.parent == object.parent else { return false }
          guard self.registeredAsParallelCapable == object.registeredAsParallelCapable else { return false }
          guard self.unnamedModule == object.unnamedModule else { return false }
          return true
        }

        public static func == (lhs: ClassLoader, rhs: ClassLoader) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(applicationName: String? = nil, autowireCapableBeanFactory: AutowireCapableBeanFactory? = nil, beanDefinitionCount: Int? = nil, beanDefinitionNames: [String]? = nil, classLoader: ClassLoader? = nil, displayName: String? = nil, environment: Environment? = nil, id: String? = nil, parent: ApplicationContext? = nil, parentBeanFactory: BeanFactory? = nil, startupDate: Int? = nil) {
        self.applicationName = applicationName
        self.autowireCapableBeanFactory = autowireCapableBeanFactory
        self.beanDefinitionCount = beanDefinitionCount
        self.beanDefinitionNames = beanDefinitionNames
        self.classLoader = classLoader
        self.displayName = displayName
        self.environment = environment
        self.id = id
        self.parent = parent
        self.parentBeanFactory = parentBeanFactory
        self.startupDate = startupDate
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        applicationName = try container.decodeIfPresent("applicationName")
        autowireCapableBeanFactory = try container.decodeIfPresent("autowireCapableBeanFactory")
        beanDefinitionCount = try container.decodeIfPresent("beanDefinitionCount")
        beanDefinitionNames = try container.decodeArrayIfPresent("beanDefinitionNames")
        classLoader = try container.decodeIfPresent("classLoader")
        displayName = try container.decodeIfPresent("displayName")
        environment = try container.decodeIfPresent("environment")
        id = try container.decodeIfPresent("id")
        parent = try container.decodeIfPresent("parent")
        parentBeanFactory = try container.decodeIfPresent("parentBeanFactory")
        startupDate = try container.decodeIfPresent("startupDate")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(applicationName, forKey: "applicationName")
        try container.encodeIfPresent(autowireCapableBeanFactory, forKey: "autowireCapableBeanFactory")
        try container.encodeIfPresent(beanDefinitionCount, forKey: "beanDefinitionCount")
        try container.encodeIfPresent(beanDefinitionNames, forKey: "beanDefinitionNames")
        try container.encodeIfPresent(classLoader, forKey: "classLoader")
        try container.encodeIfPresent(displayName, forKey: "displayName")
        try container.encodeIfPresent(environment, forKey: "environment")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(parent, forKey: "parent")
        try container.encodeIfPresent(parentBeanFactory, forKey: "parentBeanFactory")
        try container.encodeIfPresent(startupDate, forKey: "startupDate")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ApplicationContext else { return false }
      guard self.applicationName == object.applicationName else { return false }
      guard self.autowireCapableBeanFactory == object.autowireCapableBeanFactory else { return false }
      guard self.beanDefinitionCount == object.beanDefinitionCount else { return false }
      guard self.beanDefinitionNames == object.beanDefinitionNames else { return false }
      guard self.classLoader == object.classLoader else { return false }
      guard self.displayName == object.displayName else { return false }
      guard self.environment == object.environment else { return false }
      guard self.id == object.id else { return false }
      guard self.parent == object.parent else { return false }
      guard self.parentBeanFactory == object.parentBeanFactory else { return false }
      guard self.startupDate == object.startupDate else { return false }
      return true
    }

    public static func == (lhs: ApplicationContext, rhs: ApplicationContext) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
